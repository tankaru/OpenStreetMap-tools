<html>
<head>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.3.1/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.3.1/dist/leaflet.js"></script>
    <script src='https://unpkg.com/mapillary-js@2.20.0/dist/mapillary.min.js'></script>
    <link href='https://unpkg.com/mapillary-js@2.20.0/dist/mapillary.min.css' rel='stylesheet' />
<style type="text/css">

</style>
</head>
<body onload="initMap()">
<h1>[TEST]Route view simulator</h1>
<div style="float:left">
<div id='mapcontainer' style='width: 640px; height: 480px;margin: 10px;'></div>

<ul style="display:none;">
	<li>min lat: <span id="minlat"></span></li>
	<li>max lat: <span id="maxlat"></span></li>
	<li>min lon: <span id="minlon"></span></li>
	<li>max lon: <span id="maxlon"></span></li>
</ul>

<input type="button" style="font-size:50px;" value="Find route" onclick="findRoute()">


<ul>
<li>Routing is powered by <a href="https://www.graphhopper.com/">GraphHopper API</a></li>
<li>Images from <a href="https://www.mapillary.com/">Mapillary</a></li>
</ul>
</div>


<div id='mly' style='width: 640px; height: 480px;　margin: 10px;'></div>
<div style='align: center;'>
<input type="button" style="font-size:50px;" value="⏴" onclick="goBackward()">
<input type="button" style="font-size:50px;" value="⏸" onclick="stopMove()">
<input type="button" style="font-size:50px;" value="⏵" onclick="goForward()">
</div>
<div id="results"></div>
<div id="test"></div>
<script src="utils.js"></script>
<script>

let map;
let start_marker;
let end_marker;
let present_marker;
var mly;
let timer;
let count = 0;
let maxcount;
let finepoints;
let route;


//https://tech-blog.s-yoshiki.com/2018/05/92/
function hubeny(lat1, lng1, lat2, lng2) {
    function rad(deg) {
        return deg * Math.PI / 180;
    }
    //degree to radian
    lat1 = rad(lat1);
    lng1 = rad(lng1);
    lat2 = rad(lat2);
    lng2 = rad(lng2);

    // 緯度差
    var latDiff = lat1 - lat2;
    // 経度差算
    var lngDiff = lng1 - lng2;
    // 平均緯度
    var latAvg = (lat1 + lat2) / 2.0;
    // 赤道半径
    var a = 6378137.0;
    // 極半径
    var b = 6356752.314140356;
    // 第一離心率^2
    var e2 = 0.00669438002301188;
    // 赤道上の子午線曲率半径
    var a1e2 = 6335439.32708317;

    var sinLat = Math.sin(latAvg);
    var W2 = 1.0 - e2 * (sinLat * sinLat);

    // 子午線曲率半径M
    var M = a1e2 / (Math.sqrt(W2) * W2);
    // 卯酉線曲率半径
    var N = a / Math.sqrt(W2);

    const t1 = M * latDiff;
    const t2 = N * Math.cos(latAvg) * lngDiff;
    return Math.sqrt((t1 * t1) + (t2 * t2));
}
function sphericalTrigonometry(lat1, lng1, lat2, lng2) {
    // 赤道半径
    var R = 6378137.0;

    function rad(deg) {
        return deg * Math.PI / 180;
    }

    return R *
        Math.acos(
            Math.cos(rad(lat1)) *
            Math.cos(rad(lat2)) *
            Math.cos(rad(lng2) - rad(lng1)) +
            Math.sin(rad(lat1)) *
            Math.sin(rad(lat2))
        );
}

function earthDistance(point1, point2){
  return hubeny(point1[1], point1[0], point2[1], point2[0]);
}

function dividePoints(points, distance){
  let finePoints = [];
  for(let i=0; i<points.length-1;i++){
    const section_length = earthDistance(points[i],points[i+1]);
    const dlat = points[i+1][1]-points[i][1];
    const dlon = points[i+1][0]-points[i][0];    
    const ddlat = dlat * distance/section_length;
    const ddlon = dlon * distance/section_length;
    
    let dist = 0;
    let j = 0;
    finePoints.push(points[i])
    while(true){
      dist +=distance;
      if (dist>section_length) break;
      j++;
      finePoints.push([points[i][0]+j*ddlon,points[i][1]+j*ddlat]);
    }

  }
  return finePoints;
}


var findRoute = function(){

	const start = start_marker.getLatLng();
	const end = end_marker.getLatLng();
	let startlon = start.lng;
	let startlat = start.lat;
	let endlon = end.lng;
	let endlat = end.lat;
	


	let request = new XMLHttpRequest();
	const url = 'https://graphhopper.com/api/1/route?point=' + startlat + ',' + startlon + '&point=' + endlat + ',' + endlon + '&vehicle=car&locale=ja&calc_points=true&key=1d71cf85-3c57-462f-9ecb-3307df72d594&instructions=true';
	//alert(url);
	request.open('GET', url , true);
	request.onload = function () {
		const results = JSON.parse(this.response);
		const points = decodePath(results["paths"][0]["points"]);
		//alert(JSON.stringify(points));
		finepoints = dividePoints(points, 10);
		maxcount = finepoints.length;

		route.remove();
		route = L.polyline(L.GeoJSON.coordsToLatLngs(finepoints), { color: 'blue', weight: 5 }).addTo(map);
		//route.redraw();
		
		moveImage(1);


	}
	request.send();
}

var nextImage = function(){
	moveImage(1);
}

var prevImage = function(){
	moveImage(-1);
}

var goForward = function(){
	clearInterval(timer);
	timer = setInterval(nextImage, 3000);
}

var goBackward = function(){
	clearInterval(timer);
	timer = setInterval(prevImage, 3000);
}

var stopMove = function(){
	clearInterval(timer);
}



function moveImage(move){
	let request = new XMLHttpRequest();
	const url = 'https://a.mapillary.com/v3/images?client_id=NEh3V0ZjaE1fT1Nkdk9jMnJlSGNQQTplZDBiMjFkZjcxNjFhNjEw&closeto=' + finepoints[count][0] + ',' + finepoints[count][1] + '&lookat=' + finepoints[count+move][0] + ',' + finepoints[count+move][1] +'&radius=10&pano=false';
	//document.getElementById('test').innerText = count + '/' + maxcount;

	request.open('GET', url, true);
	request.onload = function () {
		const data = this.response;
		//document.getElementById('test').innerText = JSON.stringify(data);
		const jsondata = JSON.parse(data);
		const features = jsondata["features"];
		if (features.length > 0){
			const feature = features[0];
			const properties = feature["properties"];
			const key = properties["key"];
			console.log(key);
			mly.moveToKey(key)
				.then(
					function(node) { console.log(node.key); },
					function(error) { console.error(error); });

		};
		count += move;
		if (count <1 || count > maxcount-1){
			clearInterval(timer);
		}
		else {
			present_marker.setLatLng(L.GeoJSON.coordsToLatLng(finepoints[count]));
		}
	};
	request.send();

}

//http://ktgis.net/service/leafletlearn/index.html
function initMap() {
	mly = new Mapillary.Viewer(
		'mly',
		// client id
		'NEh3V0ZjaE1fT1Nkdk9jMnJlSGNQQTplZDBiMjFkZjcxNjFhNjEw',
		// photo id
		'NQOAvAiFpxlx7uZvuDAObw',
		//activate immediately
		{
			component: {
				cover: false,
			},
		});
  //地図を表示するdiv要素のidを設定
  map = L.map('mapcontainer');
  //地図の中心とズームレベルを指定
  map.setView([35.46045, 139.62993], 16);

  //https://stackoverflow.com/questions/22948096/get-the-bounding-box-of-the-visible-leaflet-map
  map.on('moveend', function() {
	document.getElementById('minlat').innerText = map.getBounds().getSouth();
	document.getElementById('maxlat').innerText = map.getBounds().getNorth();
	document.getElementById('minlon').innerText = map.getBounds().getWest();
	document.getElementById('maxlon').innerText = map.getBounds().getEast();
});

  //表示するタイルレイヤのURLとAttributionコントロールの記述を設定して、地図に追加する
  L.tileLayer('http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
	  attribution: "(C)<a href='https://www.openstreetmap.org/copyright' target='_blank'>OpenStreetMap contributors</a>",
	  maxZoom: 21,
	  maxNativeZoom: 19,
	  minZoom: 15,
	  maxBounds: [[35.47, 139.62], [35.45, 139.64]],
  }).addTo(map);
  
	start_marker = L.marker( [35.461171, 139.630570], { draggable: true }).bindTooltip("Start").addTo( map );
	end_marker = L.marker( [35.459693, 139.628883], { draggable: true }).bindTooltip("End").addTo( map );
	present_marker = L.marker(L.GeoJSON.coordsToLatLng([35.461171, 139.630570])).bindTooltip("Present").addTo(map);

}

</script>
</body>
</html>

